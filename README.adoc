// SPDX-License-Identifier: Apache-2.0 OR EUPL-1.2
= jfmt
:toc: macro

*jfmt* is a *standalone Java source code formatter* ‚Äî fast, consistent, and ready for CI.

image:https://github.com/bmarwell/jfmt/actions/workflows/build.yml/badge.svg["Build",link=https://github.com/bmarwell/jfmt/actions/workflows/build.yml]
image:https://codecov.io/github/bmarwell/jfmt/graph/badge.svg?token=97T490QXQ2["codecov",link=https://codecov.io/github/bmarwell/jfmt]
image:https://img.shields.io/badge/License-Apache_2.0-blue.svg["License",link=https://opensource.org/licenses/Apache-2.0]
image:https://img.shields.io/badge/License-EUPL_1.2-blue["License EUPL",link=https://joinup.ec.europa.eu/software/page/eupl]
image:https://img.shields.io/github/all-contributors/bmarwell/jfmt?color=ee8449&style=flat-square["All Contributors",link="#contributors"]

toc::[]

== What is jfmt?

*jfmt* is an *opinionated command-line Java formatter* with a *sane default configuration*.
It is built on top of the Eclipse JDT formatter engine ‚Äî but unlike the Eclipse IDE, *jfmt* runs completely standalone as a native binary or JAR.

It‚Äôs designed for developers who want:

* predictable, idempotent formatting;
* a fast, zero-configuration CLI tool;
* an easy way to enforce consistent formatting locally *and* in CI.

In short:
*Run it locally before you commit. Let CI check it again.*
*jfmt* also normalizes all source files to UTF-8 encoding and Unix line endings (`\n`) to ensure consistent formatting across operating systems and editors.
That‚Äôs all you need.

== Quick Start

. **Install or build jfmt**
+
You can run jfmt as a native binary or as a portable JAR (see <<Compiling>>).

. **Format your code locally**
+
[source,console]
----
# Format and rewrite all Java files
jfmt write src/

# Or just check which files need formatting
jfmt list --all .

# Show a diff of what would change
jfmt diff --all .
----

. **Workflow Summary**
+
|===
| Action | Who | Purpose
| `jfmt write` | Developer | Format files locally before committing
| `jfmt diff`  | CI pipeline | Verify formatting consistency
| `jfmt list`  | Developer or CI | List unformatted files
|===

== Why not Spotless or Checkstyle?

*Spotless* and *Checkstyle* are *Maven or Gradle plugins* that integrate deeply into build lifecycles.
*jfmt*, on the other hand, is a *self-contained command-line tool* designed to be lightweight and fast ‚Äî closer to `gofmt` or `rustfmt`.

|===
| Tool | Integration | Configuration | Typical Use
| Spotless | Maven/Gradle plugin | Customizable | In build lifecycle
| Checkstyle | Maven/Gradle plugin | Highly customizable | Style rule enforcement
| jfmt | CLI tool / native binary | No config needed | Pre-commit & CI enforcement
|===

*jfmt* complements these tools: you can use it alongside Checkstyle or in projects where build tooling is minimal.

== Goals

* üö´‚Äã‚öôÔ∏è No config file by default
  ** ship a sane default config, similar to https://github.com/palantir/palantir-java-format[palantir-java-format].
* ü™û idempotent operation
  ** do not do other/additional changes upon subsequent reformat operations
* üìù reading and writing
  ** allows output on stdout or overwriting the input files
* üöØ no AST loss
  ** do not swallow comments, intentional empty lines and line breaks, etc.
* üöÄ FAST
  ** The project aims to create a GraalVM-based binary for most architectures, so it can operate
     almost as fast as `gofmt` or similar tools.

== Implementation

* üíª Uses PicoCLI for command line parsing
* üìù Uses Eclipse JDT for formatting
* ‚öôÔ∏è Uses GraalVM for creating native, statically linked stand-alone binaries
* Automatically converts non-UTF-8 inputs to UTF-8 and replaces mixed or Windows line endings (`\r\n`) with Unix (`\n`) endings before formatting.

=== Implementation status

The following commands are implemented:

write/fix::
    Rewrite the given files in place, if they are not formatted correctly.

list::
    List all files that are not formatted correctly.

print::
    Print the formatted version of the given files to stdout.

diff::
    Print a (unified) diff of the given files to stdout.

=== Roadmap

Features:

* [x] basic commands implemented
* [x] basic tests implemented
* [x] CI/CD implemented
* [ ] Formatting of import statements (link:https://github.com/bmarwell/jfmt/issues/34[#34])
* [ ] Refinement of default formatting rules

Distribution:

* [ ] native binaries for Linux, Windows, MacOS
* [ ] package for Homebrew
* [ ] package for Scoop
* [ ] package for apt/dpkg
* [ ] package for rpm/yum/dnf
* [ ] package for Chocolatey
* [ ] package for winget
* [ ] package for SDKMAN


== Compiling

* Use Maven 4 or the Maven wrapper
* JDK 25 required

You can use `mvn verify` to create a tested and verified runnable application archive using jreleaser.
You can find and execute the archive in the path `cli/target/jreleaser/assemble/jfmt/java-archive`.
More info about these kinds of archives can be found in my blog post: https://blog.bmarwell.de/2025/04/12/creating-app-distribution-using-maven-jreleaser.html[Creating an App Distribution with Apache Maven and JReleaser].

Please note that Java 25 or better needs to be installed on your system and must be in the `PATH` environment variable.

=== Native Binaries

Why use native binaries?
Because they are fast, small, and do not require a JRE to be installed on the system.

Here is a simple comparison of this project running with both options:

.Native Binary
[source,console]
----
‚ùØ time ./cli/target/jfmt-0.1.0-SNAPSHOT list --all .
Processing file: ./cli/src/main/java/io/github/bmarwell/jfmt/nio/PathUtils.java
Processing file: ./cli/src/test/resources/diff/SomeRecord.java
Not formatted correctly: ./cli/src/test/resources/diff/SomeRecord.java
Processing file: ./integration-tests/jreleaser-builtin/src/test/resources/correctly_formatted/CorrectlyFormatted.java
Processing file: ./integration-tests/jreleaser-builtin/src/test/resources/incorrectly_formatted/SomeRecord.java
Not formatted correctly: ./integration-tests/jreleaser-builtin/src/test/resources/incorrectly_formatted/SomeRecord.java
Processing file: ./integration-tests/jreleaser-builtin/src/test/java/io/github/bmarwell/jfmt/its/jreleaser/builtin/WriteCommandIT.java
Processing file: ./cli/src/test/java/io/github/bmarwell/jfmt/JFmtTest.java
Processing file: ./integration-tests/jreleaser-builtin/src/test/resources/write/t001/SomeRecord.java
Not formatted correctly: ./integration-tests/jreleaser-builtin/src/test/resources/write/t001/SomeRecord.java
[...]
jfmt list --all .  0,03s user 0,02s system 95% cpu 0,057 total
----

.JAR Distribution
[source,console]
‚ùØ time ./cli/target/jreleaser/assemble/jfmt/java-archive/work/jfmt-0.1.0-SNAPSHOT/bin/jfmt list --all .
Processing file: ./cli/src/main/java/io/github/bmarwell/jfmt/nio/PathUtils.java
Processing file: ./cli/src/test/resources/diff/SomeRecord.java
Not formatted correctly: ./cli/src/test/resources/diff/SomeRecord.java
Processing file: ./integration-tests/jreleaser-builtin/src/test/resources/correctly_formatted/CorrectlyFormatted.java
Processing file: ./integration-tests/jreleaser-builtin/src/test/resources/incorrectly_formatted/SomeRecord.java
Not formatted correctly: ./integration-tests/jreleaser-builtin/src/test/resources/incorrectly_formatted/SomeRecord.java
[...]
jfmt list --all .  2,29s user 0,13s system 281% cpu 0,860 total
----

As you can see, the native binary is about three times faster than the JAR distribution.

==== Compiling native binaries on linux

By default, a profile `dist-linux` is activated, which will create a native binary for Linux x86_64 using musl.
If you do not have musl and `libz.a` installed, you can use the profile `'-Pnative,!dist-linux'` to create a native binary using glibc instead.

== Further reading

* https://jqno.nl/post/2024/08/24/why-are-there-no-decent-code-formatters-for-java/[Why are there no decent code formatters for Java?] ‚Äì by Jan Ouwens.
* link:++https://help.eclipse.org/latest/index.jsp?topic=%2Forg.eclipse.jdt.doc.isv%2Freference%2Fapi%2Forg%2Feclipse%2Fjdt%2Fcore%2Fformatter%2FDefaultCodeFormatterConstants.html++[Class DefaultCodeFormatterConstants] ‚Äì the reference for the JDT code formatter config.
* https://github.com/diffplug/spotless/tree/main/plugin-maven#eclipse-jdt[Spotless Maven Plugin JDT setup] ‚Äì the reference.

== FAQ

Why not call it `javafmt`?::
The JAVA¬Æ brand name is a registered trademark of Oracle, and except in limited circumstances, may not be used without a
written license from Oracle.
The ‚ÄúJava‚Äù name may be used in product, service, and event names without permission only in specific, limited ways.
+
‚Ä¶ also, I wanted to keep the book open for the OpenJDK community to adopt an official tool with this name.

How opinionated is it?::
While there is a default rule, you can use other named rules or even foreign config files created by Eclipse IDE as well.
But I encourage everyone to use the default configuration ‚Äì and let's discuss how well it is defined in the GitHub discussions and the issue tracker.

[#contributors]
== Contributors

include::CONTRIBUTORS.adoc[leveloffset=2]

See link:CONTRIBUTORS.adoc[CONTRIBUTORS.adoc] for a list of all contributors.

== License

This work is dual-licensed under Apache 2.0 and EUPL 1.2.
You may choose either license when using this work.

----
SPDX-License-Identifier: Apache-2.0 OR EUPL-1.2
----
